1. `if(a > b > c){}`中`a > b > c`为逻辑运算，首先若`a > b`成立，则`a > b = 1`，再计算`1 > c`。
2. 变量类型转换原则：低级向高级转化。
   级别（从低到高）：int，float，double。
   若要高级向低级转换:就要用到强制类型转换符。
4. 浮点数的比较不可以用`==`或者`!=`。
5. 十进制浮点数无法转化为精确的二进制浮点数，故float不能参与位运算。
6. 1. 层次模型：层次模型是以记录类型为结点的树型结构，下层记录是上层记录中某元素的细化。 层次模型的记录类型间只有简单的层次关系，且满足以下条件：有一个记录类型没有父结点；其他记录类型有且只有一个父结点。
   2. 网状模型： 有一个以上记录类型没有父结点；至少有一个记录类型多于一个父结点。用这种网络结构表示记录类型之间联系的模型称为网状模型。
   3. 关系模型：关系模型的基本思想是把事物与事物之间的联系用二维表格的形式描述。一个关系可以看作一个二维表，表中每一行是一个记录，每一列是一个字段。 关系模型可用离散数学中的关系代数来描述，因而关系数据库管理系统能够用严格的数学理论来描述数据库的组织和操作，且具有简单灵活、数据独立性高等特点，应用十分广泛
7. 拷贝初始化构造函数的作用是将一个已知对象的数据成员值拷贝给正在创建的另一个同类的对象
8. 静态函数不可以是虚函数，因为静态函数没有this。静态是编译时期就必须确定的，虚函数是运行时期确定的。
9. 虚函数可以声明为inline。
10. 不能声明为虚函数的函数包括：
   1. 只有类的成员函数才能声明为虚函数。
   2. 静态成员函数不能是虚函数。
   3. 内联函数不能是虚函数。
   4. 构造函数不能是虚函数。
   5. 析构函数可以是虚函数，而且通常声明为虚函数。
11. 函数重载：在同一作用域中，同名函数的形式参数（参数个数，类型或顺序）不同，构成函数重载，与返回值类型无关。
12. C++中一维数组的名字就是指向该数组的第一个元素的指针。
13. new分为两步：1.给对象分配内存(operator new())和malloc等同。2.调用构造函数
    delete也是两步: 1.调用析构函数。2.回收空间(如果是malloc就用free回收)
14. malloc和free不需要调用构造函数和析构函数。
15. 一个容器就是一些特定类型对象的集合。
16. 所有成员函数默认为内联函数。
17. 构造函数和析构函数没有返回值（并不是返回值为void）。
18. 构造函数可以被重载。
19. 在类中：
    1. 如果什么都没有，则类占用1个字节，一旦类中有其他的占用空间成员，则这1个字节就不在计算之内。
    2. 虚函数存在一个虚函数表，需要4个字节。
    3. 如果只有成员函数，则还是只占用1个字节，因为类函数不占用空间。
    4. 数据成员对象如果为指针则为4字节。
    5. 为类创建一个实例对象的时候，是无需再为static成员变量分配空间的，所以，当sizeof计算类的大小的时候会忽略static成员变量的大小。
    6. 考虑对齐规则（为了提高访问速度）
20. 静态分配发生在程序编译和连接的时候，动态分配则发生在程序调入和执行的时候。
21. 堆只是动态分配的，不能静态分配。
22. 栈既可以静态分配（编译器完成，如局部变量分配），又可以动态分配（函数alloca() 完成），并且栈的动态分配由编译器进行释放。
23. 数据传递方式只有两种：值传递和引用传递。地址传递本质上也是值传递。值传递为单向传递（地址传递可实现双向），引用传递为双向传递。 
24. 80X86架构：小端寻址。
25. 字符串长度比设定长度大就按字符串实际长度输出。
26. 字符串长度比设定长度小就按右对齐输出该字串,左补空格。
27. 如果数字之前有-，即%-5s表示左对齐输出
28. 编译器会自动生成构造函数，析构函数，赋值构造函数，拷贝构造函数，取值函数。
29. 类中可以存在超过一个拷贝构造函数。
30. 静态数据成员：
    1. 在类的声明中使用 static 关键字声明静态数据成员，但不进行初始化。
    2. 在类的定义外进行静态数据成员的定义和初始化。
    3. 不依赖于类的实例。它不属于类的任何特定实例，而是属于整个类。
    4. 所有类的实例共享同一个静态数据成员。
31. 静态成员函数：
    1. 静态成员函数不能访问非静态数据成员和非静态成员函数。
    2. 通过类名直接调用静态成员函数，而不需要创建类的实例。
    3. 静态成员函数不依赖于特定的实例，它属于整个类。
    4. 静态成员函数不具有 this 指针，因为它不依赖于特定的实例。
    5. 不能在静态成员函数中访问非静态成员。
32. 类的方法后面加了const后，该方法的实现中不能修改类的成员。
33. 预处理命令行不能以分号结尾。
34. 凡是以#号开头的行，都被称为编译预处理命令行。
35. 预处理命令行可以出现在程序的最后一行，预处理命令行作用域是整个文件。
36.  \*p++, 后缀++优先级高于解引用\*， \*++p，前缀++优先级和解引用*一样。
37. ftell() 函数用于得到文件位置指针当前位置相对于文件首的偏移字节数。  
    fseek()函数用于设置文件指针的位置。  
    rewind()函数用于将文件内部的位置指针重新指向一个流(数据流/文件)的开头。
    ferror()函数可以用于检查调用输入输出函数时出现的错误。
38. 进行实例化的类成员实例化顺序是按照其声明顺序决定。
39. !(A && B) == !A || !B  
    !(A || B) == !A && !B
40. 每一个模板形参名前面必须有一个typename或者class(不可省略)。
41. C++中，后置++/--，返回的都是右值，是拷贝。前置++/--返回的是左值，是自身引用。
42. 在C++中，前置++/--重载的是operator++()，后置++/--重载是operator++(int)。
43. 指针类型，32位就是4，64位就是8 。
44. strlen只接受字符串常量（const char*）。
45. 含有纯虚函数的类不能被实例化。
46. 含有纯虚函数的类一定是抽象类。
47. const void print(const int num)const 第一个const修饰返回类型 第二个const修饰参数 第三个const修饰调用对象。
48. 








# 字符串
```C++
#include <iostream>
#include <string>  //提供C++对字符串处理的功能
#include <cstring>  //提供C语言对字符串处理的有关函数
using namespace std;

int main(){
    //初始化
    //1. 字符串初始化
    string str1 = "Hello World";  //string str("Hello World")
    //2. 初始化为包含5个字符的string对象，每个字符都是a
    string str2(5, 'a');
    //3. 拷贝构造函数
    string str3(str1);

    //获取字符串长度
    //1. size()
    int str_size = str1.size();
    //2. length()
    int ste_length = str1.length();

    //字符串拼接
    //1. 使用+ 或者 += 运算符可以在string对象后追加字符或string对象
    str3 = str1 + str2;
    str3 += str1;
    str3 += 'a';
    str3 += "abc";
    //2. append()
    str3.append("abc");
    str3.append(str1);
    str3.append(4,'a');  //在字符串str3结尾添加4个字符a
    str3.append(str1, 2, 3);  //把字符串str1中从2开始的3个字符连接到字符串str3的结尾
    str3.append(str1.begin() + 2, str1.end());  //把str1的迭代器begin()+2和end()之间的部分连接到当前字符串的结尾
    //3. push_back() 参数为单个字符
    str3.push_back('a')

    //获取子字符串 sbustr(start_pos, length)，不指定length则截取到字符串的结尾
    string str4 = str1.substr(1, 3);

    //查找
    //1. find/rfind
    int pos = str1.find("Hello");

    //字符串的比较
    string str1 = "Hello";
    string str2 = "World";
    //1. 使用关系运算符比较string对象
   if (str1 == str2) {
       std::cout << "str1 等于 str2" << std::endl;
   } else if (str1 < str2) {
       std::cout << "str1 小于 str2" << std::endl;
   } else {
       std::cout << "str1 大于 str2" << std::endl;
   }
   //2. 使用strcmp函数比较char数组中的字符串
   char charStr1[] = "Hello";
   char charStr2[] = "World";
   int result = std::strcmp(charStr1, charStr2);
   if (result == 0) {
       std::cout << "charStr1 等于 charStr2" << std::endl;
   } else if (result < 0) {
       std::cout << "charStr1 小于 charStr2" << std::endl;
   } else {
       std::cout << "charStr1 大于 charStr2" << std::endl;
   }



    //访问字符串元素
    //1. 使用[]进行下标访问
    char c1 = str1[1];
    //2. at()
    char c1 = str.at(0);

    //获取字符串第一个字符front()和最后一个字符back()
	  char front = str_1.front();
	  char back = str_1.back();

    return 0;
}
```

3. 字符串对象不需要NULL字符结尾。
4. 字符串中的字符依次存储在内存中一块连续的区域内，并且把空字符'\0'自动附加到字符串的尾部最为字符串的结束标志，即**C/C++中的字符串结束符为'\0'，字符个数为n的字符串在内存中应占（n+1）个字节**。
5. `sizeof(a)`是指字符串a的内存空间大小（包括最后的\0），返回的是整个字符串包括'\0'在内占用的字节数（n+1）。
6. `strlen()`查找到"\0"就结束（不包括最后的\0）。
7. 字符串可以整体输入输出
8. string对象允许使用`+`或`+=`实现两个字符串的连接操作。
9. string对象可以使用关系运算符比较大小（重载了运算符）。
10. char数组中的字符串要用`strcmp()`进行比较，不能用关系运算符。
11. 


### 读取解析逗号分隔的数据
使用 getline 和 stringstream 以 ',' 为分隔符来切分数据
```C++
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    string n;
    cin >> n;
    stringstream ss(n);
    string temp;
    while (getline(ss, temp, ',')) {
        cout << temp << endl;
    }
    return 0;
}
```
   




### 1. C++和 C 的区别是什么？
C++是C的超集，也就是说，C++包括了C的所有基础特性，并且还增加了一些新的特性。C++代码可以包含C代码，且大多数C代码可以在C++中编译和运行。
1. 面向对象编程(OOP)  
C++ 支持面向对象的编程语言，而 C 不支持。面向对象编程是一种编程范式，允许将数据和操作数据的函数封装在对象中，以便更容易管理和组织代码。因此，C++ 支持类、继承、封装、多态等一系列面向对象的概念和特性。 
2. 标准模板库(STL)  
C++ 标准库比 C 标准库更加完善和强大。C++ 标准库包括了很多容器类，如 vector、map、set 等，以及输入输出流、字符串处理等常用功能。
3. 类和对象  
C++引入了类和对象的概念，这允许开发者创建自定义数据类型（类），并使用这些类来创建对象。这有助于实现封装、继承和多态等面向对象编程的特性。
4. C++还引入了一些其他的语言特性，如异常处理、命名空间、构造函数和析构函数，这些都有助于更好地组织和维护代码。

### 2. 重载和重写的区别
1. 重写：  
在派生类中重新定义基类的虚函数的行为。当基类中的某个虚函数在派生类中被重新定义时，如果派生类对象调用该函数，则会覆盖掉基类中的实现，执行派生类中的实现代码。在进行对象的多态性转换时，重写非常重要。
2. 重载：  
在同一个作用域内声明几个同名但是参数列表不同的函数。通过函数名相同但参数类型、个数或顺序的不同，可以让多个函数具有不同的行为。例如，C++ 中可以重载函数来处理不同类型的数据，如整数、浮点数等。在使用函数时，根据传递给函数的参数类型和个数来自动选择对应的函数进行调用。因此，重写和重载的主要区别在于，重写是通过派生类重新定义基类虚函数的行为，以实现运行时多态性；而重载是在同一作用域内声明几个相同名称的函数，以实现编译时多态性。
### 3. 讲讲面向对象
面向对象编程有 3 大特性：
1. 封装：封装是指将对象的属性和方法绑定在一起，形成一个独立的、封闭的单元。外部只能通过对象提供的公共接口来访问或操作对象的内部状态，而无法直接访问或修改对象的数据。这样可以保证对象的内部状态不受外部干扰，从而提高了程序的安全性和可靠性，简化了代码的调用方式。
2. 继承：通过继承机制，一个类可以从另一个类中继承某些属性和方法，并在此基础上添加新的属性和方法，从而避免了重复编写代码的冗余，提高了代码的可重用性和可维护性。
3. 多态：多态是指同一个消息可以被不同的对象解释执行，即不同的对象对同一消息作出不同的响应。具体来说，多态可以通过虚函数和模板等机制实现。通过多态，可以使代码更加灵活、可扩展，同时也能够使程序更易读懂和维护。
这三个特性是面向对象编程的核心，它们相互配合，共同组成了一个完整的面向对象编程体系，能够有效地提高程序的可靠性、可重用性、可扩展性等方面。
### 什么是引用？




### 内存泄漏以及避免和减少这类错误的方法**？**
内存泄漏是指用动态存储分配函数动态开辟的空间，在使用完毕后未释放，导致一直占据该内存单元的情况。避免和减少内存泄漏和指针越界的错误，可以注意指针的长度、malloc时需要确定在哪里free、对指针赋值时注意被赋值指针需要不需要释放、动态分配内存的指针最好不要再次赋值、在C++中优先考虑使用智能指针等。

### malloc 和 new 的区别
malloc和new都是用于动态分配内存的函数，但它们在使用方法和效果上有一些区别：
1. 调用方式不同：malloc是C语言标准库中的函数，需要以函数调用形式调用，并且需要指定要分配的内存大小。而new是C++关键字，在使用时直接在类型后面添加括号即可，无需显式地指定内存大小。
2. 内存分配方式不同：malloc只负责分配内存空间，并返回该内存空间的起始地址，但不会进行初始化。而new除了分配内存空间外，还会自动调用构造函数对对象进行初始化。
3. 返回值类型不同：malloc返回void类型的指针，需要进行强制类型转换，才能够使用；而new返回一个指向已分配内存空间的指针，且不需要进行强制类型转换。
4. 内存分配失败时的处理方式不同：当内存分配失败时，malloc会返回NULL，并需要手动释放已经分配的内存空间；而new会抛出std::badalloc异常，程序可以通过异常捕获机制来处理。
### delete 和 free 区别
delete和free都可以用于释放动态分配的内存，但是它们之间有以下几点区别：
1. delete是C++中的运算符，而free是C语言中的函数。
2. delete会自动调用对象的析构函数来清理资源；而free只是简单地释放指针所指向的内存块。
3. delete必须要用于new动态分配的内存；而free必须要用于malloc动态分配的内存。
因此，在C++中应该使用delete来释放内存，而不是使用free。
